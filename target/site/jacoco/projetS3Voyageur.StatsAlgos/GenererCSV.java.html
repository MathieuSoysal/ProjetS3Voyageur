<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GenererCSV.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ProjetS3Voyageur</a> &gt; <a href="index.source.html" class="el_package">projetS3Voyageur.StatsAlgos</a> &gt; <span class="el_source">GenererCSV.java</span></div><h1>GenererCSV.java</h1><pre class="source lang-java linenums">package projetS3Voyageur.StatsAlgos;

import static projetS3Voyageur.StatsAlgos.CSV.writeCSV;
import static projetS3Voyageur.StatsAlgos.Repertorisation.getRepertoire;
import static projetS3Voyageur.StatsAlgos.Texte.ecrire;

import java.io.File;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;

import projetS3Voyageur.ModesDeRecherches.ModeRecherche;
import projetS3Voyageur.ModesDeRecherches.PPMulti;
import projetS3Voyageur.ModesDeRecherches.PlusProcheV3;
import projetS3Voyageur.ModesDeRecherches.TrackProchesMulti;

<span class="nc" id="L17">public class GenererCSV {</span>

    public static void main(String[] args) throws Exception {

        // #region Comparer avec les résultats de plusProche
<span class="nc" id="L22">        GenererCSV fichier = new GenererCSV();</span>
<span class="nc" id="L23">        ModeRecherche[] listAlgo = {new PlusProcheV3(), new TrackProchesMulti(), new PPMulti()};</span>
<span class="nc" id="L24">        fichier.genererComparaison(listAlgo);</span>

        // #region Generer un fichier CSV
        // ModeRecherche[] listeAlgo = { new BrutForceV2(), new BrutForceV3(), new
        // BrutForceV3_1(), new BrutForceV4(),
        // new BackTrackV1(), new BackTrackV2(), new TrackProchesV1(), new
        // TrackProchesV1_1(),
        // new TrackProchesV2() };
        // GenererCSV fichierCSV = new GenererCSV();
        // fichierCSV.setTempsMax(30);
        // fichierCSV.setNbIteration(150);
        // fichierCSV.setNbVillesMax(20);
        // fichierCSV.GenereSyncro(listeAlgo);

<span class="nc" id="L38">    }</span>

    // TODO: Néttoyer la class, Il ne respecte pas le principe Ouvert fermer
    // TODO: Cette classe doit-elle juste avec
<span class="nc" id="L42">    private byte nbVillesMax = 12;</span>
<span class="nc" id="L43">    private int nbIteration = 100;</span>
<span class="nc" id="L44">    private long tempsMax = 180;</span>

<span class="nc" id="L46">    private String nomFichier = String.valueOf(LocalDate.now()) + &quot;.csv&quot;;</span>
<span class="nc" id="L47">    private File repertoire = getRepertoire();</span>

    private ModeRecherche[] listAlgo;

<span class="nc" id="L51">    private ArrayList&lt;String[]&gt; tableauStats = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L52">    private ArrayList&lt;String[]&gt; tableauMargeErreur = new ArrayList&lt;&gt;();</span>

    /**
     * Cette méthode permet de générer un fichier CSV possèdant les statistiques de
     * temps d'exécution des différents ModeRecherche donnés en paramètre.
     * 
     * Sa spécificité réside dans le fait que pour chaque itération elle donne le
     * même pays/graphique en paramètre aux différents algorithmes, ainsi la
     * comparaison entre les différents algos est moins affectée par le facteur
     * aléatoire d'un pays/graphique.
     * 
     * 
     * @param nbVillesMax Nombre de villes où les algos doivent s'arrêter
     * @param nbIteration Nombre de fois qu'on execute les algos pour chaque nbVille
     * @param listAlgo    Liste de ModeRecherche à comparer
     * @param nonFichier  Le nom du fichier au quelle les statistique seront stocké
     */
    public void GenereSyncro(ModeRecherche[] listAlgo) {
        Analyser analyse;
<span class="nc" id="L71">        this.listAlgo = listAlgo;</span>
<span class="nc" id="L72">        initTupleSyncro();</span>
<span class="nc" id="L73">        analyse = new Analyser(listAlgo, 3, nbIteration, tempsMax);</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">        for (byte nbVille = 3; nbVille != nbVillesMax + 1; nbVille++) {</span>
<span class="nc" id="L75">            System.out.println(&quot;\n Nombre de villes actuelles :&quot; + nbVille);</span>
<span class="nc" id="L76">            analyse.setNombreDeVilles(nbVille);</span>
<span class="nc" id="L77">            analyse.analyse();</span>
<span class="nc" id="L78">            actualiseTableaux(analyse, nbVille);</span>
        }

<span class="nc" id="L81">        writeCSV(tableauMargeErreur, &quot;;&quot;, new File(repertoire, &quot;marge_d'erreur-&quot; + nomFichier));</span>
<span class="nc" id="L82">        writeCSV(tableauStats, &quot;;&quot;, new File(repertoire, &quot;stats-&quot; + nomFichier));</span>
<span class="nc" id="L83">        ConfigOrdinateur.enregistreConfig(repertoire);</span>
<span class="nc" id="L84">        ecrire(new File(repertoire, &quot;infoCourbe.txt&quot;), toString());</span>

<span class="nc" id="L86">    }</span>

    /**
     * Cette méthode permet de générer un fichier CSV possédant les statistiques
     * comparatifs entre la distance la plus courte obtenue avec l'algo donné en
     * paramètre et l'algorithme plusProche v.3.
     * 
     * Sa spécificité réside dans le fait que pour chaque itération elle donne le
     * même pays/graphique en paramètre aux différents algorithmes, ainsi la
     * comparaison entre les différents algos est moins affectée par le facteur
     * aléatoire d'un pays/graphique.
     * 
     * @param algo @{@code ModeRecherche} Algorithme de recherche qui doit être
     *             comparé
     */
    public void genererComparaison(ModeRecherche[] listAlgo) {
<span class="nc" id="L102">        Comparer cpp = new Comparer();</span>
<span class="nc" id="L103">        cpp.comparer(listAlgo);</span>

<span class="nc" id="L105">        ArrayList&lt;String[]&gt; tableau = new ArrayList&lt;&gt;();</span>

        // #region Attributs du tableau
<span class="nc" id="L108">        String[] attributs = new String[listAlgo.length + 1];</span>
<span class="nc" id="L109">        attributs[0] = &quot;Nombre de villes&quot;;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        for (byte i = 0; i != (listAlgo.length); i++) {</span>
<span class="nc" id="L111">            attributs[i + 1] = listAlgo[i].getNom();</span>
        }
        // #endregion Attributs du tableau

<span class="nc" id="L115">        tableau.add(attributs);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        for (int i = 4; i &lt; 16; i++) {</span>

<span class="nc" id="L118">            String[] tuple = new String[listAlgo.length + 1];</span>
<span class="nc" id="L119">            tuple[0] = String.valueOf(i);</span>

<span class="nc bnc" id="L121" title="All 2 branches missed.">            for (byte j = 0; j != (listAlgo.length); j++) {</span>
<span class="nc" id="L122">                tuple[j + 1] = String.valueOf(cpp.getDistancesAlgo()[i - 4][j]).replace('.', ',');</span>
            }
<span class="nc" id="L124">            tableau.add(tuple);</span>
        }

<span class="nc" id="L127">        writeCSV(tableau, &quot;;&quot;, new File(repertoire, &quot;comparaisonPlusProche&quot; + nomFichier));</span>
<span class="nc" id="L128">    }</span>

    // #region Outils

    /**
     * Insére les données de l'analyse pour un nombre de villes dans le tableau
     * 
     * @param analyse {@code Analyser} Variable contenant les données de l'analyse
     * 
     * @param nbVille {@code byte} le nombre de villes avec lequel l'analyse à été
     *                effectué
     * 
     */// TODO: l'insertions dans la base de donnée SQL peut s'effectuer ici
    private void actualiseTableaux(Analyser analyse, byte nbVille) {

<span class="nc" id="L143">        tableauStats.add(construitTuple(analyse.getListTempsMoyenAlgo(), nbVille, analyse.getMargeErreurCurrentTime()));</span>

<span class="nc" id="L145">        tableauMargeErreur</span>
<span class="nc" id="L146">                .add(construitTuple(analyse.getListMargeErreurAlgos(), nbVille, analyse.getMargeErreurCurrentTime()));</span>
<span class="nc" id="L147">    }</span>

    // #region manipulation sur les tuples

    /**
     * Initialise les attributs des tableaux (TableauStats et tableauMargeErreur)
     * sous la forme : {Nombre de ville, nom algo n°1,..., nom algo n°x, Marge
     * d'erreur du Current Time}
     */
    private void initTupleSyncro() {
<span class="nc" id="L157">        String[] attributs = new String[listAlgo.length + 2];</span>
<span class="nc" id="L158">        attributs[0] = &quot;Nombre de villes&quot;;</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (byte i = 0; i != (listAlgo.length); i++) {</span>
<span class="nc" id="L160">            attributs[i + 1] = listAlgo[i].getNom();</span>
        }
<span class="nc" id="L162">        attributs[listAlgo.length + 1] = &quot;Marge d'erreur CurrentTime&quot;;</span>
<span class="nc" id="L163">        tableauStats.add(attributs);</span>
<span class="nc" id="L164">        tableauMargeErreur.add(attributs);</span>
<span class="nc" id="L165">    }</span>

    /**
     * Construit un tuple en respectant les attributs du tableau avec les
     * informations données en paramètre
     * 
     * @param listeDouble            {@code double[]} Représente le temps mis par
     *                               les algos selon un nombre de villes
     * 
     * @param nbVille                {@code byte} Le nombre de villes représentatif
     *                               des données
     * 
     * @param margeErreurCurrentTime {@code double} Représente la marge d'erreur
     *                               lorsque l'on récupère le temps d'exécution via
     *                               la currentTime
     * 
     * @return {@code String[]} une liste de String, conforme aux attributs des
     *         tableaux c'est-à-dire : {nombre de villes, Donnée algo n°1,...,
     *         Donnée algo n°x, Marge d'erreur}
     */
    private String[] construitTuple(double[] listeDouble, byte nbVille, double margeErreurCurrentTime) {
<span class="nc" id="L186">        String[] tuple = convertToString(listeDouble);</span>
<span class="nc" id="L187">        tuple[0] = String.valueOf(nbVille);</span>
<span class="nc" id="L188">        tuple[listeDouble.length + 1] = String.valueOf(margeErreurCurrentTime).replace('.', ',');</span>
<span class="nc" id="L189">        return tuple;</span>
    }
    // #endregion manipulation sur les tuples

    /**
     * Convertie une liste de type double en une chaine de caractères conformément
     * au tuple dans les tableaux, remplace les 0 par un string vide pour éviter de
     * fausser les données du graphique.
     * 
     * @param listeDouble {@code double[]} la liste qui doit être convertie
     * 
     * @return {@code String[]} Retourne une liste de String conforme à la norme des
     *         tuples des tableaux
     */
    private String[] convertToString(double[] listeDouble) {

<span class="nc" id="L205">        String statsAlgos[] = new String[listeDouble.length</span>
<span class="nc" id="L206">                + 2 /*</span>
                     * +2 car le premier et dernier element sont réservés à l'indication du nbVille
                     * et de la marge d'erreur du currentTime
                     */];

<span class="nc bnc" id="L211" title="All 2 branches missed.">        for (int i = 0; i &lt; listeDouble.length; i++) {</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (listeDouble[i] != 0)</span>
<span class="nc" id="L213">                statsAlgos[i + 1] = String.valueOf(listeDouble[i] / 1000/* convertion en seconde */).replace('.', ',');</span>
            else
<span class="nc" id="L215">                statsAlgos[i + 1] = &quot;&quot;;</span>
        }
<span class="nc" id="L217">        return statsAlgos;</span>
    }

    // #endregion Outils

    // #region Setters

    /**
     * @param nbVillesMax the nbVillesMax to set
     */
    public void setNbVillesMax(int nbVillesMax) {
<span class="nc" id="L228">        this.nbVillesMax = (byte) nbVillesMax;</span>
<span class="nc" id="L229">    }</span>

    /**
     * @param nbIteration the nbIteration to set
     */
    public void setNbIteration(int nbIteration) {
<span class="nc" id="L235">        this.nbIteration = nbIteration;</span>
<span class="nc" id="L236">    }</span>

    /**
     * @param tempsMax the tempsMax to set
     */
    public void setTempsMax(long tempsMax) {
<span class="nc" id="L242">        this.tempsMax = tempsMax;</span>
<span class="nc" id="L243">    }</span>

    /**
     * @param nomFichier the nomFichier to set
     */
    public void setNomFichier(String nomFichier) {
<span class="nc" id="L249">        this.nomFichier = nomFichier;</span>
<span class="nc" id="L250">    }</span>

    // #endregion Setters

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
<span class="nc" id="L261">        return &quot;    GenererCSV : \n List des algorithmes de recherches =&quot; + Arrays.toString(listAlgo)</span>
<span class="nc" id="L262">                + &quot;\n nombre d'itération=&quot; + nbIteration + &quot;\n Nombre de villes maximum =&quot; + nbVillesMax</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                + &quot; \n Temps maximum=&quot; + tempsMax + &quot; seconde&quot; + ((tempsMax &gt; 1) ? &quot;s&quot; : &quot;&quot;);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>