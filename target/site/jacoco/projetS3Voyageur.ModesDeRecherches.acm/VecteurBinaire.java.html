<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VecteurBinaire.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ProjetS3Voyageur</a> &gt; <a href="index.source.html" class="el_package">projetS3Voyageur.ModesDeRecherches.acm</a> &gt; <span class="el_source">VecteurBinaire.java</span></div><h1>VecteurBinaire.java</h1><pre class="source lang-java linenums">package projetS3Voyageur.ModesDeRecherches.acm;

public class VecteurBinaire {
    private int overflow;
<span class="pc" id="L5">    private int valeurBinaire = 1;</span>
    private int listeNoireBits;

    private byte numeroNoeud;

    // #region Constructeurs
    /**
     * Chacun des bits des vecteurs binaires représantent un noeud, au sein de la
     * class les vecteurs binaires sont stockés dans un {@code int}.
     * 
     * @param valeurBinaire  Vecteur binaire dans {@code int} seul un de ces bits
     *                       doit être à 1, celui-ci représente le noeud actuel.
     * @param listeNoireBits Vecteur de bits dans un {@code int} , chacun des bits à
     *                       1 est ignoré par la class.
     * @param taille         {@code byte} L'effectif des noeuds au sein du graphe.
     */
<span class="nc" id="L21">    public VecteurBinaire(int valeurBinaire, int listeNoireBits, byte taille) {</span>
<span class="nc" id="L22">        this.valeurBinaire = valeurBinaire;</span>
<span class="nc" id="L23">        initialise(listeNoireBits, taille);</span>
<span class="nc" id="L24">    }</span>

    /**
     * Chacun des bits des vecteurs binaires représantent un noeud, au sein de la
     * class les vecteurs binaires sont stockés dans un {@code int}.
     * 
     * @param listeNoireBits Vecteur de bits dans un {@code int} , chacun des bits à
     *                       1 est ignoré par la class.
     * @param taille         {@code byte} L'effectif des noeuds au sein du graphe.
     */
<span class="nc" id="L34">    private VecteurBinaire(int listeNoireBits, byte taille) {</span>
<span class="nc" id="L35">        initialise(listeNoireBits, taille);</span>
<span class="nc" id="L36">    }</span>

    /**
     * Chacun des bits des vecteurs binaires représantent un noeud, au sein de la
     * class les vecteurs binaires sont stockés dans un {@code int}.
     * 
     * @param listeNoireBits Vecteur de bits dans un {@code int} , chacun des bits à
     *                       1 est ignoré par la class.
     * @param taille         {@code byte} L'effectif des noeuds au sein du graphe.
     */
    public static VecteurBinaire AvecTaille(int listeNoireBits, byte taille) {
<span class="nc" id="L47">        return new VecteurBinaire(listeNoireBits, taille);</span>
    }

    /**
     * Chacun des bits des vecteurs binaires représantent un noeud, au sein de la
     * class les vecteurs binaires sont stockés dans un {@code int}.
     * 
     * @param listeNoireBits Vecteur de bits dans un {@code int} , chacun des bits à
     *                       1 est ignoré par la class.
     * @param OVERFLOW       Vecteur de bits dans un {@code int} où tous les bits
     *                       représentant un noeud sont à 1 sauf le dernier bit.
     */
<span class="fc" id="L59">    private VecteurBinaire(int listeNoireBits, final int OVERFLOW) {</span>
<span class="fc" id="L60">        initialise(listeNoireBits, OVERFLOW);</span>
<span class="fc" id="L61">    }</span>

    /**
     * Chacun des bits des vecteurs binaires représantent un noeud, au sein de la
     * class les vecteurs binaires sont stockés dans un {@code int}.
     * 
     * @param listeNoireBits Vecteur de bits dans un {@code int} , chacun des bits à
     *                       1 est ignoré par la class.
     * @param OVERFLOW       Vecteur de bits dans un {@code int} où tous les bits
     *                       représentant un noeud sont à 1 sauf le dernier bit.
     */
    public static VecteurBinaire AvecOVERFLOW(int listeNoireBits, final int OVERFLOW) {
<span class="fc" id="L73">        return new VecteurBinaire(listeNoireBits, OVERFLOW);</span>
    }
    // #endregion Contructeurs

    // #region Méthodes public de la class
    /**
     * @return {@code boolean} si le bit (noeud) actuel n'est pas le dernier bit
     *         (noeud) du vecteur de bits (graphe) retourne {@code true} sinon
     *         {@code false}.
     */
    public boolean haseNext() {
<span class="fc bfc" id="L84" title="All 2 branches covered.">        return valeurBinaire &lt; overflow;</span>
    }

    /**
     * Passe au bite (noeud) suivant en fonction de la liste noire.
     */
    public void next() {
<span class="fc" id="L91">        valeurBinaire &lt;&lt;= 1;</span>
<span class="fc" id="L92">        verifieListeNoire();</span>
<span class="fc" id="L93">    }</span>
    // #endregion Méthodes public de class

    // #region Outils interne à la class
    /**
     * Vérifie que la variable valeurBinaire n'est pas dans la liste noire si elle y
     * est elle change sa valeur pour qu'elle n'y soit plus.
     */
    private void verifieListeNoire() {
<span class="fc" id="L102">        valeurBinaire += listeNoireBits;</span>
<span class="fc" id="L103">        valeurBinaire ^= (valeurBinaire &amp; listeNoireBits);</span>

<span class="fc" id="L105">        numeroNoeud = (byte) Math.getExponent(valeurBinaire);</span>
<span class="fc" id="L106">    }</span>

    private void initialise(int listeNoireBits, byte taille) {
<span class="nc" id="L109">        initialise(listeNoireBits, (1 &lt;&lt; (taille)) - 1);</span>
<span class="nc" id="L110">    }</span>

    private void initialise(int listeNoireBits, final int OVERFLOW) {
<span class="fc" id="L113">        this.overflow = OVERFLOW;</span>
<span class="fc" id="L114">        this.listeNoireBits = listeNoireBits;</span>
<span class="fc" id="L115">        verifieListeNoire();</span>
<span class="fc" id="L116">    }</span>
    // #endregion Outils interne à la class

    // #region Getters
    /**
     * 
     * @return Chaque bit du {@code int} retourné représente un noeud, seul le bit
     *         représentant le noeud actuel est à 1.
     */
    public int getValeurBinaire() {
<span class="fc" id="L126">        return valeurBinaire;</span>
    }

    /**
     * 
     * @return {@code byte} renvoie le numéro du noeud actuel.
     */
    public byte getNumeroNoeud() {
<span class="fc" id="L134">        return numeroNoeud;</span>
    }
    // #endregion Getters

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>